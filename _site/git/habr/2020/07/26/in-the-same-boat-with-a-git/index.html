<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="UTF-8">

  <link rel="canonical" href="http://localhost:4000/git/habr/2020/07/26/in-the-same-boat-with-a-git/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <meta name="description" content="Бэкап моей статьи на Хабре">

  <meta property="og:site_name" content="My digital garden">

  <link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgo=">

  <link rel="stylesheet" href="/styles.css">

  
  <meta property="og:description" content="Бэкап моей статьи на Хабре"/>
  

  
  <meta property="og:title" content="В одной лодке с "ублюдком": 11 продвинутых советов по использованию Git">
  <meta property="og:type" content="article">
  

  
  <meta property="article:published_time" content="2020-07-26T00:45:00+03:00">
  <meta property="article:author" content="http://localhost:4000/">
  

  <meta property="og:url" content="http://localhost:4000/git/habr/2020/07/26/in-the-same-boat-with-a-git/" />

  

  <title>
    
      В одной лодке с "ублюдком": 11 продвинутых советов по использованию Git &mdash; My digital garden
    
  </title>
</head>

  <body>
    <nav><div>
    <a class="internal-link" href="/"><b>My digital garden</b></a>
</div>
</nav>
    <div class="wrapper">
      <main><article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">В одной лодке с &quot;ублюдком&quot;: 11 продвинутых советов по использованию Git</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2020-07-26T00:45:00+03:00" itemprop="datePublished">Jul 26, 2020
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><a href="https://habr.com/ru/post/512490/">Бэкап моей статьи на Хабре</a></p>

<p>*“ублюдок” - вольный перевод слова “git” - “an unpleasant or contemptible person”, “неприятный или презренный человек”.</p>

<p><img src="https://habrastorage.org/webt/rn/5n/bh/rn5nbhthmyxrppdvgjiczh7v-ry.png" alt="" /></p>

<p>В комментариях к статье <a href="https://habr.com/ru/company/manychat/blog/511946/">15 базовых советов по Git для эффективной работы каждый день</a> развернулась дискуссия на тему эффективности использования тех или иных команд и опций. Надо признать, что <code class="language-plaintext highlighter-rouge">git</code> предоставляет столько различного функционала, что во-первых, за всем становится невозможно уследить, а во-вторых, его можно совершенно по-разному вписывать в рабочий процесс.</p>

<p>Давайте посмотрим, что можно использовать, чтобы улучшить себе жизнь. Статья предполагает, что читатель умеет пользоваться основными возможностями <code class="language-plaintext highlighter-rouge">git</code> и понимает что делает, когда, скажем, вводит в консоль <code class="language-plaintext highlighter-rouge">git rebase --merge --autostash</code>.</p>

<cut />

<h2 id="1-используйте-консольный-и-графический-интерфейсы-git-одновременно">1. Используйте консольный и графический интерфейсы <code class="language-plaintext highlighter-rouge">git</code> одновременно</h2>

<p>Начнём с того, как именно Вы пользуетесь возможностями git? Многие работают строго из консоли или из приложения вроде <a href="https://www.sourcetreeapp.com/">SourceTree</a>, и с первого взгляда может показаться, что эти варианты взаимоисключают друг друга.</p>

<p>Многие продвинутые редакторы, в частности, <del>Ваш любимый <code class="language-plaintext highlighter-rouge">vim</code></del> мой любимый VS Code, предоставляют как удобный доступ к консоли, так и приятный графический интерфейс для систем контроля версий, что позволяет в равной мере использовать плюсы обоих вариантов.</p>

<p>Удобства графического интерфейса очевидны невооружённым взглядом:</p>

<p><img src="https://habrastorage.org/webt/jm/o8/oh/jmo8ohq6qjncvej6gt0twuuzp5o.png" alt="" /></p>

<ul>
  <li>Вы наглядно видите изменения в файле сразу в своём любимом редакторе.</li>
  <li>Вы можете контролировать стейджинг (добавление файлов для коммита) текущих изменений практически в реальном времени, не обращаясь к <code class="language-plaintext highlighter-rouge">git status</code>.</li>
  <li>Вы получаете быстрый доступ к истории файла.</li>
  <li>… и многое другое, что зависит от конкретных редакторов и/или используемых плагинов.</li>
</ul>

<p>Удобства использования <code class="language-plaintext highlighter-rouge">git</code> из консоли не всегда очевидно для тех, кто привык пользоваться графическим интерфейсом.</p>
<ul>
  <li>В первую очередь, это поддержка всех возможных команд и опций, поскольку <code class="language-plaintext highlighter-rouge">git</code> в первую очередь консольная команда, а любой GUI - это посредник между ним и Вами.</li>
  <li>Подсказки по этим “всем возможным командам и опциям”.</li>
</ul>

<p><img src="https://habrastorage.org/webt/tt/yk/jn/ttykjnzzhnqoxdrylgd3esjogwi.png" alt="" /></p>

<ul>
  <li>Возможность применить эти команды и опции в любой комбинации. В графических интерфейсах часто “выведен наружу” только базовый набор команд, а всё что сложнее - спрятано где-то внутри. Консоль предоставляет одинаково <del>не</del>удобный интерфейс для всех команд.</li>
  <li>Подробный лог выполнения команд, описание ошибок и способы как их исправить. Банальный вывод неудачного <code class="language-plaintext highlighter-rouge">git pull --ff-only</code> при наличии входящих изменений в отредактированных файлах - сразу можно увидеть в каком файле есть несовместимые изменения и заняться мержем веток вручную:
<br />
```
    <blockquote>
      <p>git pull origin master –ff-only
From ../habr2</p>
    </blockquote>
  </li>
  <li>branch            master     -&gt; FETCH_HEAD
error: Your local changes to the following files would be overwritten by merge:
     .gitignore
Please commit your changes or stash them before you merge.
Aborting
Updating 6d1c088..a113bf7
```</li>
</ul>

<p>Соответственно, когда у вас есть доступ и к консоли, и к боковой панели, можете успешно использовать лучшее из обоих миров так, как будет удобно именно Вам.</p>

<p>Применительно к VS Code с установленным плагином GitLens хочу поделиться парочкой специфичных лайфхаков.</p>
<ul>
  <li>Привяжите хоткей к команде <code class="language-plaintext highlighter-rouge">gitlens.diffWithBranch</code> - эта команда позволяет быстро сравнить текущий файл с его версией в любой ветке.</li>
  <li>Если хотите пометить для себя место в каком-либо файле, чтобы иметь возможность быстро к нему вернуться в процессе работы над текущей веткой - просто добавьте в нужное место пустую строчку. Таким образом файл всегда будет под рукой в боковой панели. Да, для закладок существует богатый ассортимент плагинов, но обычно списки закладок быстро захламляются и в них бывает сложно ориентироваться, когда смешиваются закладки из разных веток.</li>
</ul>

<h2 id="2-конфиги-конфиги-конфиги-разделяйте-и-властвуйте">2. Конфиги, конфиги, конфиги. Разделяйте и властвуйте</h2>

<p>Да, именно три штуки: системный (<code class="language-plaintext highlighter-rouge">--system</code>), пользовательский (<code class="language-plaintext highlighter-rouge">--global</code>) и локальный (<code class="language-plaintext highlighter-rouge">--local</code>). Соответственно, они применяются в порядке иерархии, каждый последующий оверрайдит предыдущий - системный применяется для всех пользователей, пользовательский - конкретно для Вас, локальный - для конкретного репозитория. Ловко лавируя между ними, можно гибко адаптировать свой рабочий процесс под условия окружающей среды.</p>

<p><em>(Upd. Как оказалось, есть ещё четвёртый уровень конфигов, специфичный для отдельных рабочих копий одного репозитория <a href="https://git-scm.com/docs/git-worktree#_configuration_file">worktree</a>. Подробнее про worktree см. ниже.)</em></p>

<p>Когда какой стоит применять? В большинстве случаев случаев Вы предпочтёте воспользоваться глобальным, чтобы вынести в него общие для всех настройки <code class="language-plaintext highlighter-rouge">core.eol</code>, алиасы, а также <code class="language-plaintext highlighter-rouge">user.name</code> и <code class="language-plaintext highlighter-rouge">user.email</code>, переопределяя только специфические вещи для конкретного репозитория. Однако в некоторых случаях, например когда несколько разработчиков по очереди отлаживают встраиваемое ПО, часть общих настроек имеет смысл вынести на системный уровень, переопределяя в глобальном (== пользовательском) только <code class="language-plaintext highlighter-rouge">user.name</code>/<code class="language-plaintext highlighter-rouge">email</code>.</p>

<p>Также в моей практике был случай, когда в рабочих репозиториях надо было пользоваться строго рабочей почтой, при этом в своих локальных репозиториях я продолжал пользоваться личной. Чтобы даже случайно нельзя было перепутать где что, я удалил <code class="language-plaintext highlighter-rouge">user.name</code>/<code class="language-plaintext highlighter-rouge">email</code> из глобального конфига, каждый раз указывая их заново в локальном, держа процесс под контролем.</p>

<h2 id="3-используйте-временные-коммиты-вместо-stash-при-переходе-между-ветками">3. Используйте временные коммиты вместо stash при переходе между ветками</h2>

<p>Скорее всего, Вы сталкивались хотя бы раз с ситуацией, когда надо срочно переключиться с одной ветки на другую, бросив всё в разобранном состоянии. Очень вероятно, что Вы знаете про <code class="language-plaintext highlighter-rouge">git stash</code> (от англ. “тайник”), который позволяет “спрятать” Ваши текущие изменения. Однако во время его использования Вы можете столкнуться со следующими вещами:</p>
<ul>
  <li>Если коммитами Вы пользуетесь постоянно и все часто встречающиеся параметры типа <code class="language-plaintext highlighter-rouge">--amend</code> можете написать с закрытыми глазами, <code class="language-plaintext highlighter-rouge">stash</code> имеет несколько перпендикулярный интерфейс. Чтобы сохранить его надо сделать <code class="language-plaintext highlighter-rouge">git stash save</code> (при этом <code class="language-plaintext highlighter-rouge">save</code> может быть опущен). А чтобы восстановить - есть <code class="language-plaintext highlighter-rouge">git stash apply</code> (применяет последний стеш из всех) и <code class="language-plaintext highlighter-rouge">git stash pop</code> (применяет стеш и удаляет его из стека). Соответственно, когда придёт внезапная необходимость переключиться, Вы можете не сразу вспомнить, а что собственно надо вводить и что от команды ожидать.</li>
  <li>Если <code class="language-plaintext highlighter-rouge">stash</code>-ить буквально пару строчек, то можно вообще не вспомнить, что делал <code class="language-plaintext highlighter-rouge">stash</code>, и потом сидишь и удивляешься, куда делись изменения.</li>
  <li><code class="language-plaintext highlighter-rouge">stash</code> по умолчанию распространяется только на изменённые (modified) файлы и не включает в себя неотслеживаемые (untracked). Соответственно, не зная этого, при переключении веток можно потерять их, если, например, они авто-генерируемые.</li>
</ul>

<p>Что же делать, если не <code class="language-plaintext highlighter-rouge">stash</code>? Наиболее простое решение - взять и закоммитить всё с комментарием <code class="language-plaintext highlighter-rouge">WIP</code> (распространённая аббревиатура от “Work In Progress”). Не надо морочить себе голову, вспоминать названия команд и искать потом, в который из стешей сохранены изменения.</p>

<p>А зачем тогда <code class="language-plaintext highlighter-rouge">stash</code> вообще нужен? Я предпочитаю их использовать для хранения мелких фиксов, которые нужны только для отладки и не должны быть закоммичены вообще. Есть возможность применять не только последний из стешей, но и вообще любой, ссылаясь на его имя. Самое большое удобство в том, что стеши хоть и “помнят” на какой ветке были сделаны, но ни к чему не обязывают и могут быть применены на любой ветке. Я где-то когда-то нашёл очень удобные алиасы для этого:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git config <span class="nt">--global</span> alias.sshow <span class="s2">"!f() { git stash show stash^{/</span><span class="nv">$*</span><span class="s2">} -p; }; f"</span>
git config <span class="nt">--global</span> alias.sapply <span class="s2">"!f() { git stash apply stash^{/</span><span class="nv">$*</span><span class="s2">}; }; f"</span>

<span class="c"># сохранить</span>
git stash save <span class="s2">"hack"</span>
<span class="c"># посмотреть</span>
git sshow <span class="s2">"hack"</span>
<span class="c"># применить</span>
git sapply <span class="s2">"hack"</span>
</code></pre></div></div>

<h2 id="4-используйте---для-возврата-к-предыдущей-ветке">4. Используйте “<code class="language-plaintext highlighter-rouge">-</code>” для возврата к предыдущей ветке</h2>

<p>После того, как вы сделали свои <del>грязные</del> дела в другой ветке и хотите вернуться к предыдущей, вместо того чтобы вспоминать и вводить её полное имя, можно просто передать “<code class="language-plaintext highlighter-rouge">-</code>”:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git checkout -
</code></pre></div></div>

<p>Пользователям Windows этот трюк иногда совершенно незнаком, а для пользователей Linux он может быть привычен по аналогичному использованию в <code class="language-plaintext highlighter-rouge">bash</code>:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> /some/long/path
...
<span class="nb">cd</span> -
</code></pre></div></div>

<h2 id="5-не-клонируйте-репозиторий-когда-в-этом-нет-нужды">5. Не клонируйте репозиторий, когда в этом нет нужды</h2>

<p>Предположим, у вас есть две принципиально несовместимые друг с другом ветки - например, когда создаётся множество временных неотслеживаемых файлов кэша, при переходе между ветками можно замучиться их вычищать (передаю привет Unity).</p>

<p>Пришло задание срочно переключиться с одной на другую. Клонировать репозиторий вариант, но может занять уйму времени и места. Вычищать лишние файлы не вариант. На помощь приходит <code class="language-plaintext highlighter-rouge">worktree</code>: возможность держать несколько рабочих копий для одного репозитория. Из <a href="https://git-scm.com/docs/git-worktree">документации</a>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git worktree add <span class="nt">-b</span> emergency-fix ../temp master
<span class="nv">$ </span><span class="nb">pushd</span> ../temp
<span class="c"># ... hack hack hack ...</span>
<span class="nv">$ </span>git commit <span class="nt">-a</span> <span class="nt">-m</span> <span class="s1">'emergency fix for boss'</span>
<span class="nv">$ </span><span class="nb">popd</span>
<span class="nv">$ </span>git worktree remove ../temp
</code></pre></div></div>

<p>Клонирования не происходит, по сути просто чекаут в другую папку, которую потом можно оставить или не жалко удалить.</p>

<h2 id="6-применяйте-pull-только-как-fast-forward">6. Применяйте <code class="language-plaintext highlighter-rouge">pull</code> только как <code class="language-plaintext highlighter-rouge">fast-forward</code></h2>

<p>На всякий случай, напоминаю, что <code class="language-plaintext highlighter-rouge">pull</code> по умолчанию делает <code class="language-plaintext highlighter-rouge">fetch</code> (выкачивание ветки с удалённого репозитория) и <code class="language-plaintext highlighter-rouge">merge</code> (слияние локальной и удалённой веток), а <code class="language-plaintext highlighter-rouge">fast-forward</code> - это режим слияния, когда нет никаких изменений в локальной ветке и происходит “перемотка” её на последний коммит из удалённой. Если изменения есть, то происходит классический мерж с ручным разрешением конфликтов и мерж-коммитом.</p>

<p>Некоторые предпочитают использовать <code class="language-plaintext highlighter-rouge">git pull --rebase</code>, но не всегда это возможно, например, когда вы локально смержили другую ветку из <code class="language-plaintext highlighter-rouge">origin</code> в <code class="language-plaintext highlighter-rouge">master</code> и перед пушем делаете <code class="language-plaintext highlighter-rouge">pull</code> (надеюсь, не надо напоминать, чем в данном случае может грозить <code class="language-plaintext highlighter-rouge">rebase</code>).</p>

<p>Соответственно, чтобы не попасть случайно в ситуацию, когда Вы неудачным <code class="language-plaintext highlighter-rouge">pull</code>-ом смержили не то и не туда, можно использовать параметр <code class="language-plaintext highlighter-rouge">--ff-only</code> или вписать соответствую опцию в конфиг:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git config <span class="nt">--global</span> pull.ff only
</code></pre></div></div>

<p>Что мы получаем?</p>
<ul>
  <li>Автоматический фейл, если в локальной ветке есть новые незапушенные коммиты.</li>
  <li>Автоматический фейл, если во входящей ветке есть изменения в тех же файлах, в которых у Вас есть локальные незакоммиченные изменения (а это с большой вероятностью может вылиться потом в конфликт мержа).</li>
  <li>Автоматический фейл, если Вы случайно делаете <code class="language-plaintext highlighter-rouge">pull</code> не в ту ветку - например, на автомате вписали <code class="language-plaintext highlighter-rouge">git pull origin</code> <del><code class="language-plaintext highlighter-rouge">master</code></del> <code class="language-plaintext highlighter-rouge">upstream</code> вместо <code class="language-plaintext highlighter-rouge">my_feature</code>.</li>
  <li>Успех, когда всё прекрасно.</li>
</ul>

<h2 id="7-скрывайте-лишнее-через-git-exclude">7. Скрывайте лишнее через <code class="language-plaintext highlighter-rouge">git exclude</code></h2>

<p>Обычно для скрытия файлов используется <code class="language-plaintext highlighter-rouge">.gitignore</code>, но он практически всегда отслеживается в самом репозитории и любое его изменение приведёт к тому, что он будет считаться изменённым на нашей стороне или может привести к неожиданному скрытию новых файлов у всех остальных.</p>

<p>Для решения этого вопроса есть чудесная возможность добавить соответствующий паттерн в файл <code class="language-plaintext highlighter-rouge">.git/info/exclude</code>. А для удобства редактирования этого файла можно использовать алиас:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git config <span class="nt">--global</span> alias.exclude <span class="s1">'!f() { vim .git/info/exclude; }; f'</span>
</code></pre></div></div>
<p>(Не забудьте подставить Ваш любимый редактор.)</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">.git/info/exclude</code> использует тот же синтаксис, что и <code class="language-plaintext highlighter-rouge">.gitignore</code>.</li>
  <li>Добавленные туда паттерны будут скрывать файлы только в вашем репозитории.</li>
  <li>Обратите внимание, что их действие, как и у <code class="language-plaintext highlighter-rouge">.gitignore</code> распространяется только на неотслеживаемые (untracked) файлы. Уже отслеживаемые изменённые файлы будут “подсвечиваться” как и раньше. Если Вы добавили файл случайно и теперь хотите его скрыть (такое иногда бывает с локальными конфигами IDE, например, <code class="language-plaintext highlighter-rouge">.vscode/settings.json</code>), используйте <code class="language-plaintext highlighter-rouge">git rm &lt;path&gt; --cached</code> - команда удалит файл из отслеживаемых, но оставит его локальную копию нетронутой, и вот теперь её можно будет скрыть через exclude.</li>
  <li>Если хотите скрыть ряд файлов из всех-всех репозиториев, Вам поможет:
<br />
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git config <span class="nt">--global</span> core.excludesfile &lt;path to global .gitignore&gt;
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="8-скрывайте-локальные-изменения-когда-не-хотите-их-вливать">8. Скрывайте локальные изменения, когда не хотите их “вливать”</h2>

<p>А теперь про то, когда Вы не хотите чтобы отслеживались <em>изменённые</em> файлы. Яркий пример: очень многие, особенно долгоживущие репозитории, хранят в себе ряд конфигов. Часто они служат для обеспечения единообразия настроек (к примеру, <code class="language-plaintext highlighter-rouge">.editorconfig</code>) или тасков сборки/линтинга (<code class="language-plaintext highlighter-rouge">.vscode/tasks.json</code>). И иногда так случается, что хочется их как-то изменить, но возможность разделения конфигов на “общие” и “пользовательские” отсутствует.</p>

<p>Есть административный вариант решения проблемы: вынести все конфиги в отдельную папку, из которой каждый будет сам копировать конфиги в нужные места. И есть <del>путь одиночки</del> возможность заоверрайдить на месте и пометить файл как <em>неизменённый</em>:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git update-index <span class="nt">--assume-unchanged</span> &lt;path to file&gt;
</code></pre></div></div>

<p>С этих пор он “пропадает с радаров” даже если Вы продолжите его изменять. Если во время <code class="language-plaintext highlighter-rouge">pull</code>-а приходят новые изменения в этом же файле - в этом случае он будет продолжать считаться неизменённым, но легко смержиться Вам не даст. Чтобы вернуть всё как было, надо снять флаг, добавив <code class="language-plaintext highlighter-rouge">no</code>:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git update-index <span class="nt">--no-assume-unchanged</span> &lt;path to file&gt;
</code></pre></div></div>

<h2 id="9-отслеживайте-хаки-локальные-изменения-в-обход-репозитория">9. Отслеживайте <del>хаки</del> локальные изменения в обход репозитория</h2>

<p>Теперь немного чёрной магии. Предположим, что Вы не только изменили конфиги, но и хотите сохранить их в истории, чтобы помнить, почему Вы так сделали, и иметь возможность переключаться между разными версиями. Или же хотите отслеживать файлы, которые в принципе игнорируются главным репозиторием. Суть одна, в основной репозиторий заливать их нельзя. <code class="language-plaintext highlighter-rouge">stash</code> в этом может помочь, но когда разных изменений накапливается много, в них можно <del>прострелить</del> сломать ногу.</p>

<p>В моей практике было время, когда сборка проекта приводила к автогенерации части рабочих конфигов. Подставлять вручную такие, какие нужны для отладки, - замучаешься. Хотелось получить возможность быстро их чекаутить. Был вариант сделать репозиторий в папке <code class="language-plaintext highlighter-rouge">./out</code> - но оказалось, что постоянно переходить из папки в папку тоже неудобно.</p>

<p>Долго ли, коротко ли, узнал я о том, что вовсе необязательно, чтобы папка с репозиторием называлась <code class="language-plaintext highlighter-rouge">.git</code>. Её можно назвать как угодно ещё на этапе создания репозитория и работать с ней, передавая в команды параметр <code class="language-plaintext highlighter-rouge">gitdir</code>. А значит… Просто выполнить <code class="language-plaintext highlighter-rouge">git init --separate-git-dir=.git_dev</code> в существующей папке нам не дадут, произойдёт переименование каталога. Поэтому делаем хитрее: выполняем команду в новой папке, и кладём свежесозданный репозиторий рядом с существующим.</p>

<p>Что только что сейчас произошло? Мистическим образом у нас оказалось два репозитория в одной папке, а значит и возможность вести параллельную историю файлов! Почему <code class="language-plaintext highlighter-rouge">.git_dev</code>? Да для единообразия. Давайте заведём себе алиас, чтобы упростить работу со вторым репозиторием:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git config <span class="nt">--global</span> alias.dev <span class="s1">'!git --git-dir=\"./.git_dev\"'</span>
</code></pre></div></div>

<p>Пробуем:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; git status -s
?? .git_dev/

&gt; git dev status -s
?? .git_dev/
?? .gitignore
?? Program.cs
?? habr.csproj
</code></pre></div></div>

<p>Со вторым репозиторием Вы теперь вольны делать всё что захотите. Можете отслеживать только отдельные конфиги, а можете вести полностью параллельную историю, добавляя в неё что-то своё и делая <code class="language-plaintext highlighter-rouge">checkout</code> то одного, то другого (правда, не знаю зачем это может пригодиться, но вдруг Вы <del>шизофреник</del> сложный человек).</p>

<p>Игнорировать <code class="language-plaintext highlighter-rouge">.git/</code> у гита заложено в генах, а вот всё остальное, как мы видим, отображается как есть. Наибольшая проблема - <code class="language-plaintext highlighter-rouge">.gitignore</code> у них будет один на двоих, так что практически всё, что может потребоваться во втором репозитории, придётся добавлять через <code class="language-plaintext highlighter-rouge">-f</code>, а всё что не требуется - не забываем игнорировать через <code class="language-plaintext highlighter-rouge">.git_dev/info/exclude</code>. По умолчанию можно добавить следующие строчки:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># ignore all files
</span><span class="o">/*</span>
<span class="c1"># ignore all folders
</span><span class="o">*/</span>
</code></pre></div></div>

<p>В качестве бонуса, саму идею использования <code class="language-plaintext highlighter-rouge">git</code> для отслеживания конфигов можно использовать в том числе для того, чтобы хранить все свои заботливо собранные <code class="language-plaintext highlighter-rouge">.vimrc</code>, <code class="language-plaintext highlighter-rouge">.bashrc</code>, создавая репозиторий прямо в <code class="language-plaintext highlighter-rouge">~</code> (для Windows это <code class="language-plaintext highlighter-rouge">C:\Users\%USERNAME%\</code>).</p>

<h2 id="10-используйте-хуки">10. Используйте хуки</h2>

<p>Про хуки много рассказано в других статьях, <a href="https://habr.com/ru/post/75063/">например</a> и <a href="https://habr.com/ru/post/329804/">вот</a>, но не упомянуть их нельзя. Благодаря <code class="language-plaintext highlighter-rouge">git bash</code> они одинаково работают как в Unix-like системах так и в Windows, правда, если они при этом запускают что-то ещё, можно огрести приключений. Полезны, например, хуки:</p>
<ul>
  <li>прогоняющие код через линтер/автоформаттер перед коммитом;</li>
  <li>вычленяющие номер задачи из текущей ветки и добавляющие её в сообщение коммита;</li>
  <li>пересобирающие вспомогательные библиотеки после чекаута и мержа.</li>
</ul>

<p>Из любопытного, когда-то я себе ставил хук на чекаут, который писал название ветки в <a href="https://github.com/projecthamster/hamster">Hamster</a>, что позволяло достаточно точно отслеживать когда и над чем я работал. А при использовании <code class="language-plaintext highlighter-rouge">.git_dev</code> из предыдущего пункта можно настроить его автоматический чекаут после чекаута основного репозитория, чтобы всегда держать у себя “правильные” локальные версии конфигов.</p>

<h2 id="11-требуйте-автодополнение">11. Требуйте автодополнение</h2>

<p>Напоследок хочу сказать довольно банальную вещь - автодополнение существенно улучшает качество жизни. В большинстве Unix-систем оно идёт из коробки, но если Вас угораздило оказаться в инфраструктуре Windows - настоятельно рекомендую перейти на <a href="https://github.com/PowerShell/PowerShell">Powershell</a> (если ещё не) и установить <a href="https://github.com/dahlbyk/posh-git">posh-git</a>, который обеспечивает автодополнение большинства команд и даёт минималистичную сводку в prompt:</p>

<p><img src="https://habrastorage.org/webt/pq/vt/40/pqvt40l61xgcw6dcddwdhufa1lo.png" alt="" /></p>

<hr />

<p>Спасибо за внимание; желаю всем приятной и эффективной каждодневной работы.</p>

<hr />

<p>Бонус для внимательных. Упомянутые выше и несколько неупомянутых алиасов из конфига:</p>

<div class="language-ini highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[alias]</span>
    <span class="c"># `git sshow hack` - показать содержимое стеша с названием, включающим "hack". Строка может быть неточной
</span>    <span class="py">sshow</span> <span class="p">=</span> <span class="s">"!f() { git stash show stash^{/$*} -p; }; f"</span>

    <span class="c"># `git sapply hack` - применить стеш "hack"
</span>    <span class="py">sapply</span> <span class="p">=</span> <span class="s">"!f() { git stash apply stash^{/$*}; }; f"</span>

    <span class="c"># работа с `.git_dev`
</span>    <span class="py">dev</span> <span class="p">=</span> <span class="s">!git --git-dir=</span><span class="se">\"</span><span class="s">./.git_dev</span><span class="se">\"</span>

    <span class="c"># отображение статуса одновременно `.git/` и `.git_dev/`
</span>    <span class="py">statys</span> <span class="p">=</span> <span class="s">"!f() { git status ; echo </span><span class="se">\"\n\"</span><span class="s"> ; git dev status ; }; f"</span>

    <span class="c"># поиск ветки по части названия
</span>    <span class="py">findb</span> <span class="p">=</span> <span class="s">"!f(){ git branch -ra | grep $1; }; f"</span>

    <span class="c"># последние пять коммитов в ветке. Если вызвать как `git hist -n 10`, отобразит 10
</span>    <span class="py">hist</span> <span class="p">=</span> <span class="s">log --pretty=format:</span><span class="se">\"</span><span class="s">%ad | %h | %an: </span><span class="se">\t</span> <span class="s">%s%d</span><span class="se">\"</span> <span class="s">--date=short -n5</span>

    <span class="c"># `git dist branch-name` отображает разницу в списке коммитов между текущей веткой и branch-name
</span>    <span class="py">dist</span> <span class="p">=</span> <span class="s">"!git log --pretty=format:</span><span class="se">\"</span><span class="s">%ad | %h | %an: </span><span class="se">\t</span><span class="s"> %s%d</span><span class="se">\"</span><span class="s"> --date=short </span><span class="se">\"</span><span class="s">$(git rev-parse --abbrev-ref HEAD)</span><span class="se">\"</span><span class="s"> --not "</span>

    <span class="c"># редактирование локального `exclude`
</span>    <span class="py">exclude</span> <span class="p">=</span> <span class="s">"!f() { vim .git/info/exclude; }; f"</span>

    <span class="c"># вывести список файлов, скрытых через `--assume-unchanged`
</span>    <span class="py">ignored</span> <span class="p">=</span> <span class="s">!git ls-files -v | grep "^[[:lower:]]"</span>

    <span class="c"># переход на следующий коммит - операция, обратная `git reset HEAD~1`
</span>    <span class="py">forward</span> <span class="p">=</span> <span class="s">"!f() { git log --pretty=oneline --all | grep -B1 `git rev-parse HEAD` | head -n1 | egrep -o '[a-f0-9]{20,}' | xargs git checkout ; }; f"</span>
</code></pre></div></div>

  </div><a class="u-url" href="/git/habr/2020/07/26/in-the-same-boat-with-a-git/" hidden></a>
</article>
</main>
      <footer>This is the footer. Include anything you'd like here, like a link to an <a class="internal-link" href="/about">About</a> page.
</footer>
    </div>

    <!-- That file is not particularly elegant. This will need a refactor at some point. -->
<style>
  content a.internal-link {
    border-color: #8b88e6;
    background-color: #35373f;
  }

  #tooltip-wrapper {
    background: rgb(65, 65, 65);
    padding: 1em;
    border: 1px solid #ddd;
    border-radius: 4px;
    overflow: hidden;
    position: absolute;
    width: 400px;
    height: 250px;
    font-size: 0.8em;
    box-shadow: 0 5px 10px rgba(0, 0, 0, 0.1);
    opacity: 0;
    transition: opacity 100ms;
  }

  #tooltip-wrapper:after {
    content: "";
    position: absolute;
    z-index: 1;
    bottom: 0;
    left: 0;
    pointer-events: none;
    background-image: linear-gradient(to bottom, rgba(255, 255, 255, 0), rgba(0, 0, 0, 0.6) 90%);
    width: 100%;
    height: 75px;
  }
</style>

<div style="opacity: 0; display: none;" id='tooltip-wrapper'>
  <div id='tooltip-content'>
  </div>
</div>

<iframe style="display: none; height: 0; width: 0;" id='link-preview-iframe' src="">
</iframe>

<script>
  var opacityTimeout;
  var contentTimeout;
  var transitionDurationMs = 100;

  var iframe = document.getElementById('link-preview-iframe')
  var tooltipWrapper = document.getElementById('tooltip-wrapper')
  var tooltipContent = document.getElementById('tooltip-content')

  function hideTooltip() {
    opacityTimeout = setTimeout(function () {
      tooltipWrapper.style.opacity = 0;
      contentTimeout = setTimeout(function () {
        // TODO: post-link support
        if (!tooltipContent)
          return;

        tooltipContent.innerHTML = '';
        tooltipWrapper.style.display = 'none';
      }, transitionDurationMs + 1);
    }, transitionDurationMs);
  }

  function showTooltip(event) {
    var elem = event.target;
    var elem_props = elem.getClientRects()[elem.getClientRects().length - 1];
    var top = window.pageYOffset || document.documentElement.scrollTop;

    if (event.target.host === window.location.host) {
      iframe.src = event.target.href
      iframe.onload = function () {
        // TODO: post-link support
        if (!tooltipContent)
          return;

        tooltipContentHtml = '';

        let headerContent = iframe.contentWindow.document.querySelector('h1');
        let content = iframe.contentWindow.document.querySelector('content');

        if (!headerContent || !content)
          return;

        tooltipContentHtml += '<div style="font-weight: bold;">' + headerContent.innerHTML + '</div>';
        tooltipContentHtml += content.innerHTML;

        tooltipContent.innerHTML = tooltipContentHtml;

        tooltipWrapper.style.display = 'block';
        setTimeout(function () {
          tooltipWrapper.style.opacity = 1;
        }, 1);
      }

      tooltipWrapper.style.left = elem_props.left - (tooltipWrapper.offsetWidth / 2) + (elem_props.width / 2) + "px";
      if ((window.innerHeight - elem_props.top) < (tooltipWrapper.offsetHeight)) {
        tooltipWrapper.style.top = elem_props.top + top - tooltipWrapper.offsetHeight - 10 + "px";
      } else if ((window.innerHeight - elem_props.top) > (tooltipWrapper.offsetHeight)) {
        tooltipWrapper.style.top = elem_props.top + top + 35 + "px";
      }

      if ((elem_props.left + (elem_props.width / 2)) < (tooltipWrapper.offsetWidth / 2)) {
        tooltipWrapper.style.left = "10px";
      } else if ((document.body.clientWidth - elem_props.left - (elem_props.width / 2)) < (tooltipWrapper.offsetWidth / 2)) {
        tooltipWrapper.style.left = document.body.clientWidth - tooltipWrapper.offsetWidth - 20 + "px";
      }
    }
  }

  function setupListeners(linkElement) {
    linkElement.addEventListener('mouseleave', function (_event) {
      hideTooltip();
    });

    tooltipWrapper.addEventListener('mouseleave', function (_event) {
      hideTooltip();
    });

    linkElement.addEventListener('mouseenter', function (event) {
      clearTimeout(opacityTimeout);
      clearTimeout(contentTimeout);
      try {
        showTooltip(event);
      } catch (e) { }
    });

    tooltipWrapper.addEventListener('mouseenter', function (event) {
      clearTimeout(opacityTimeout);
      clearTimeout(contentTimeout);
    });
  }

  document.querySelectorAll('content a').forEach(setupListeners);
</script>

  </body>
</html>
